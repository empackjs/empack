import{_ as t,c as i,o as r,ae as a}from"./chunks/framework.BG0qUWSs.js";const m=JSON.parse('{"title":"Empack","description":"","frontmatter":{},"headers":[],"relativePath":"introduction/what-is-empack.md","filePath":"introduction/what-is-empack.md"}'),o={name:"introduction/what-is-empack.md"};function s(n,e,d,l,c,p){return r(),i("div",null,e[0]||(e[0]=[a('<h1 id="empack" tabindex="-1">Empack <a class="header-anchor" href="#empack" aria-label="Permalink to &quot;Empack&quot;">‚Äã</a></h1><p>An Express-based web server framework.</p><h2 id="description" tabindex="-1">Description <a class="header-anchor" href="#description" aria-label="Permalink to &quot;Description&quot;">‚Äã</a></h2><p><strong>Empack</strong> is a <strong>lightweight alternative to NestJS</strong>, built on top of <strong>Express</strong> with a focus on simplicity, minimalism, and fast developer onboarding. While it offers a familiar, structured development experience like Nest, Empack deliberately avoids heavy abstractions and rigid architecture, making it ideal for small to medium-sized projects that prioritize <strong>flexibility and productivity</strong>.</p><p>Unlike NestJS, Empack embraces a <strong>zero-friction</strong> philosophy‚Äîhelping developers focus on business logic without being constrained by the framework‚Äôs structure or boilerplate code.</p><p>Empack is fully compatible with the existing Express ecosystem, allowing seamless integration with popular Express middleware, libraries, and tools.</p><p>It comes with built-in features including:</p><ul><li>A dependency injection container powered by <a href="https://github.com/inversify/InversifyJS" target="_blank" rel="noreferrer">Inversify</a></li><li>Route-based WebSocket support</li><li>A mediator pattern implementation for CQRS</li><li>Automatic OpenAPI documentation generation</li></ul><p>With TypeScript decorators, Empack simplifies the registration of controllers, routes, OpenAPI metadata, and more. Its built-in mediator enables a clean separation of concerns, fully decoupling controllers from business logic‚Äîmaking CQRS and modular architecture straightforward to adopt.</p><h2 id="empack-vs-nestjs-key-differences" tabindex="-1">Empack vs NestJS: Key Differences <a class="header-anchor" href="#empack-vs-nestjs-key-differences" aria-label="Permalink to &quot;Empack vs NestJS: Key Differences&quot;">‚Äã</a></h2><table tabindex="0"><thead><tr><th>Feature / Design Aspect</th><th><strong>Empack</strong></th><th><strong>NestJS</strong></th></tr></thead><tbody><tr><td>üß± Base Architecture</td><td>Built directly on Express (thin abstraction)</td><td>Built on Express or Fastify with heavy abstraction</td></tr><tr><td>üíâ Dependency Injection</td><td>Custom DI container with <strong>singleton / transient / request-scope</strong> support</td><td>Built-in DI, request-scope is limited and not supported in middleware</td></tr><tr><td>‚öôÔ∏è Middleware Injection</td><td>Middleware shares the same request container as controllers</td><td>Middleware is singleton and cannot inject request-scoped providers</td></tr><tr><td>üì° WebSocket Routing</td><td>Path-based routing, per-connection container, DI and auth supported</td><td>Centralized Gateway (singleton), namespace-based only</td></tr><tr><td>üì¶ Module System</td><td>No module requirement; everything can be wired via DI</td><td>Everything must be registered inside a <code>@Module()</code></td></tr></tbody></table><p>Empack aims to be the sweet spot between Express&#39;s flexibility and NestJS&#39;s structure ‚Äî without the ceremony. It gives you:</p><ul><li>Modern DI with request-scoped injection</li><li>Lazy middleware resolution</li><li>Path-based WebSocket routing with full per-request context</li><li>Minimal but powerful decorators</li><li>Zero need to register modules, or fight the framework</li></ul>',13)]))}const h=t(o,[["render",s]]);export{m as __pageData,h as default};
